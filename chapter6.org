#+TITLE: Typeclasses

[[file:README.org][Back to Prelude]]

* Notes
+ Typeclasses allow us to generalize over a set of types
  in order to define and execute a standard set of features
  for those types.
  + For example, the ability to test values for equality.
    We can test any data of a type that implements the typeclass
    known as "Eq" for equality.

#+BEGIN_SRC haskell
Prelude> :info Bool
data Bool = False | True
instance Bounded Bool
instance Enum Bool
instance Eq Bool
instance Ord Bool
instance Read Bool
instance Show Bool
#+END_SRC

+ The information includes the data declaration for Bool and
  which typeclasses it already has instances of.
  1. ~instance Bounded Bool~ for types that have an upper and lower
     bound
  2. ~instance Enum Bool~ for things that can be enumerated
  3. ~instance Eq Bool~ for things that can be tested for equality
  4. ~instance Org Bool~ for things that can be put into a sequential order
  5. ~instance Read Bool~ parses strings into other types
     + Book says not to use it apparently
  6. ~instance Show Bool~ renders things into strings

+ Typeclasses have a hierarchy of sorts
  + All ~Fractional~ numbers implement the ~Num~ typeclass,
    but not all ~Num~ are ~Fractional~ as an example.
  + All members of ~Ord~ are members of ~Eq~, and all members
    of ~Enum~ are members of ~Ord~

#+BEGIN_SRC haskell
Prelude> :info Eq
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool

instance Eq a => Eq [a]
instance Eq Ordering
instance Eq Int
instance Eq Float
instance Eq Double
instance Eq Char
instance Eq Bool
instance (Eq a, Eq b) => Eq (a, b)
instance Eq ()
instance Eq a => Eq (Maybe a)
instance Eq Integer
#+END_SRC

+ First it tells we have a typeclass called ~Eq~ that have two
  functions, ~==~ and ~/=~ ("equal to" and "not equal to")
  + Both operators take two type variables that have an instance
    of ~Eq~ and return a ~Bool~
+ Then it lists what types are instances of ~Eq~

#+BEGIN_SRC haskell
data (,) a b = (,) a b
instance (Eq a, Eq b) => Eq (a, b)
instance (Ord a, Ord b) => Ord (a, b)
instance (Read a, Read b) => Read (a, b)
instance (Show a, Show b) => Show (a, b)
#+END_SRC

+ This tells us the equality of two tuples (a, b) depends on the
  equality of their constituent values.
  + which is why ~(1, 'a') == (2, 'b')~ works
    but ~(1, 2) == ('a', 'b')~ doesn't
    + basically alpha equivalence

#+BEGIN_SRC haskell
data Trivial = Trivial
#+END_SRC

+ With no ~deriving~ clause on this type declaration, there is no
  typeclass instance of any kind.
+ If we run ~Trivial == Trivial~, it will give a type error complaining
  about no instance for (Eq Trivial) arising from the use of ~==~
+ This should fix it

  #+BEGIN_SRC haskell
data Trivial = Trivial' -- Data constructors don't need the same name

instance Eq Trivial where
  Trivial' == Trivial' = True
  #+END_SRC

+ ~instance~ begins a declaration for a typeclass instance, which is
  how equality, stringification, orderability, enumeration, or other typeclasses
  should work for a particular datatype.
+ The first name after ~instance~ is the typeclass the instance is providing.
  + In this case ~Eq~
+ The next is the type the instance is being provided for.
  + which is ~Trivial~ in this case
+ ~where~ ends the declaration and beginning of the instance. What follows
  are the functions being implemented.
+ ~Trivial'~ is the first/left argument to the ~==~ function, followed by another
  ~Trivial'~ as the second/right argument, then the result of the code is
  declared to evaluate to True

#+BEGIN_SRC haskell
data DayOfWeek =
  Mon | Tue | Weds | Thu | Fri | Sat | Sun

data Date =
  Date DayOfWeek Int
#+END_SRC

+ Can't do anything with this yet since there are no operations defined for them...
  yet

#+BEGIN_SRC haskell
instance Eq DayOfWeek where
  (==) Mon Mon = True
  (==) Tue Tue = True
  (==) Weds Weds = True
  (==) Thu Thu = True
  (==) Fri Fri = True
  (==) Sat Sat = True
  (==) Sun Sun = True
  (==) _ _ = False
#+END_SRC

+ This is obviously just to see if two given days are the same, else false.
  Now to write an ~Eq~ instance for type ~Date~

#+BEGIN_SRC haskell
instance Eq Date where
  (==) (Date weekday dayOfMonth)
       (Date weekday' dayOfMonth') =
    weekday == weekday'
  && dayOfMonth == dayOfMonth'
#+END_SRC

+ Test if it works

#+BEGIN_SRC haskell
Prelude> Date Thu 10 == Date Thu 10
True
Prelude> Date Thu 10 == Date Thu 11
False
Prelude> Date Thu 10 == Date Weds 10
False
#+END_SRC

+ It works, also we can't print them in the REPL yet since there is no
  ~Show~ instance.
