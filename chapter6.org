#+TITLE: Typeclasses

[[file:README.org][Back to Prelude]]

* Notes
+ Typeclasses allow us to generalize over a set of types
  in order to define and execute a standard set of features
  for those types.
  + For example, the ability to test values for equality.
    We can test any data of a type that implements the typeclass
    known as "Eq" for equality.

#+BEGIN_SRC haskell
Prelude> :info Bool
data Bool = False | True
instance Bounded Bool
instance Enum Bool
instance Eq Bool
instance Ord Bool
instance Read Bool
instance Show Bool
#+END_SRC

+ The information includes the data declaration for Bool and
  which typeclasses it already has instances of.
  1. ~instance Bounded Bool~ for types that have an upper and lower
     bound
  2. ~instance Enum Bool~ for things that can be enumerated
  3. ~instance Eq Bool~ for things that can be tested for equality
  4. ~instance Ord Bool~ for things that can be put into a sequential order
  5. ~instance Read Bool~ parses strings into other types
     + Book says not to use it apparently
  6. ~instance Show Bool~ renders things into strings

+ Typeclasses have a hierarchy of sorts
  + All ~Fractional~ numbers implement the ~Num~ typeclass,
    but not all ~Num~ are ~Fractional~ as an example.
  + All members of ~Ord~ are members of ~Eq~, and all members
    of ~Enum~ are members of ~Ord~

#+BEGIN_SRC haskell
Prelude> :info Eq
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool

instance Eq a => Eq [a]
instance Eq Ordering
instance Eq Int
instance Eq Float
instance Eq Double
instance Eq Char
instance Eq Bool
instance (Eq a, Eq b) => Eq (a, b)
instance Eq ()
instance Eq a => Eq (Maybe a)
instance Eq Integer
#+END_SRC

+ First it tells we have a typeclass called ~Eq~ that have two
  functions, ~==~ and ~/=~ ("equal to" and "not equal to")
  + Both operators take two type variables that have an instance
    of ~Eq~ and return a ~Bool~
+ Then it lists what types are instances of ~Eq~

#+BEGIN_SRC haskell
data (,) a b = (,) a b
instance (Eq a, Eq b) => Eq (a, b)
instance (Ord a, Ord b) => Ord (a, b)
instance (Read a, Read b) => Read (a, b)
instance (Show a, Show b) => Show (a, b)
#+END_SRC

+ This tells us the equality of two tuples (a, b) depends on the
  equality of their constituent values.
  + which is why ~(1, 'a') == (2, 'b')~ works
    but ~(1, 2) == ('a', 'b')~ doesn't
    + basically alpha equivalence

#+BEGIN_SRC haskell
data Trivial = Trivial
#+END_SRC

+ With no ~deriving~ clause on this type declaration, there is no
  typeclass instance of any kind.
+ If we run ~Trivial == Trivial~, it will give a type error complaining
  about no instance for (Eq Trivial) arising from the use of ~==~
+ This should fix it

  #+BEGIN_SRC haskell
data Trivial = Trivial' -- Data constructors don't need the same name

instance Eq Trivial where
  Trivial' == Trivial' = True
  #+END_SRC

+ ~instance~ begins a declaration for a typeclass instance, which is
  how equality, stringification, orderability, enumeration, or other typeclasses
  should work for a particular datatype.
+ The first name after ~instance~ is the typeclass the instance is providing.
  + In this case ~Eq~
+ The next is the type the instance is being provided for.
  + which is ~Trivial~ in this case
+ ~where~ ends the declaration and beginning of the instance. What follows
  are the functions being implemented.
+ ~Trivial'~ is the first/left argument to the ~==~ function, followed by another
  ~Trivial'~ as the second/right argument, then the result of the code is
  declared to evaluate to True

#+BEGIN_SRC haskell
data DayOfWeek =
  Mon | Tue | Weds | Thu | Fri | Sat | Sun

data Date =
  Date DayOfWeek Int
#+END_SRC

+ Can't do anything with this yet since there are no operations defined for them...
  yet

#+BEGIN_SRC haskell
instance Eq DayOfWeek where
  (==) Mon Mon = True
  (==) Tue Tue = True
  (==) Weds Weds = True
  (==) Thu Thu = True
  (==) Fri Fri = True
  (==) Sat Sat = True
  (==) Sun Sun = True
  (==) _ _ = False
#+END_SRC

+ This is obviously just to see if two given days are the same, else false.
  Now to write an ~Eq~ instance for type ~Date~

#+BEGIN_SRC haskell
instance Eq Date where
  (==) (Date weekday dayOfMonth)
       (Date weekday' dayOfMonth') =
    weekday == weekday'
  && dayOfMonth == dayOfMonth'
#+END_SRC

+ Test if it works

#+BEGIN_SRC haskell
Prelude> Date Thu 10 == Date Thu 10
True
Prelude> Date Thu 10 == Date Thu 11
False
Prelude> Date Thu 10 == Date Weds 10
False
#+END_SRC

+ It works, also we can't print them in the REPL yet since there is no
  ~Show~ instance.

+ Partial application /= partial function.
  + A partial function is one that doesn't handle all the possible cases.
    + Partial functions bad
+ If we were to take our ~DayOfWeek~ code without ~(==) _ _ = False~
  and have it compare two different values
  (i.e. ~Mon == Tue~) we would get this

#+BEGIN_SRC haskell
Prelude> Mon == Tue
\*** Exception: code/derivingInstances.hs:
(19,3)-(25,23):
Non-exhaustive patterns in function ==
#+END_SRC

+ The ~_~ is important since it provides a fallback case, or an "else" condition
  like in imperative languages. Without it pattern matching becomes non-exhaustive.
+ Another example of using this fallback mechanism

#+BEGIN_SRC haskell
f :: Int -> Bool
f 1 = True
f 2 = True
f 3 = True
f _ = False
#+END_SRC

+ We sometimes need to require our argument(s) to provide some typeclass
  instances for us in order to write an instance for the datatype containing them
  when we're writing an instance of a typeclass for something with polymorphic
  parameters

#+BEGIN_SRC haskell
data Identity a =
  Identity a

instance Eq (Identity a) where
  (==) (Identity v) (Identity v') = v == v'
#+END_SRC

+ What we want is to rely on whatever ~Eq~ instances the arguments to Identity
  (~a~ in the datatype declaration and ~v~ in the instance definition) has already.
  However the code will throw an error complaining about having no instance for ~(Eq a)~
  arising from a use of '=='.
+ Both ~v~ and ~v'~ are both of type ~a~ but we don't know anything about it
+ We can fix it with the same typeclass constraint syntax used with functions like so

#+BEGIN_SRC haskell
instance Eq a => Eq (Identity a) where
  (==) (Identity v) (Identity v') = v == v
#+END_SRC

+ This should work because we now know ~a~ has to have an instance of ~Eq~
+ Also Haskell will ensure that we don't check equality with values that don't
  have an ~Eq~ instance

#+BEGIN_SRC haskell
class Num a where
(+) :: a -> a -> a
(*) :: a -> a -> a
(-) :: a -> a -> a
negate :: a -> a
abs :: a -> a
signum :: a -> a
fromInteger :: Integer -> a

instance Num Integer
instance Num Int
instance Num Float
instance Num Double
#+END_SRC

+ This is the typeclass ~Num~ and some of its instances and functions

#+BEGIN_SRC haskell
class (Real a, Enum a) => Integral a where
  quot :: a -> a -> a
  rem :: a -> a -> a
  div :: a -> a -> a
  mod :: a -> a -> a
  quotRem :: a -> a -> (a, a)
  divMod :: a -> a -> (a, a)
  toInteger :: a -> Integer
#+END_SRC

+ This is the typeclass ~Integral~
+ The typeclass constraint ~(Real a, Enum a)~ means that any type that implements
  ~Integral~ must have instances of those two. So an integral type must be both
  a real number and enumerable and can therefore employ the methods of those typeclasses
+ In turn, the ~Real~ typeclass requires an instance of ~Num~, so the ~Integral~ class
  may put the methods of ~Real~ and ~Num~ into effect.
+ ~Real~ can't override the methods of ~Num~

#+BEGIN_SRC haskell
class (Num a) => Fractional a where
  (/) :: a -> a -> a
  recip :: a -> a
  fromRational :: Rational -> a
#+END_SRC

+ This is the ~Fractional~ typeclass, and its type argument ~a~
  also an instance of ~Num~, this is another example of typeclass inheritance
+ ~Fractional~ applies to fewer numbers than ~Num~ does
+ Instances of ~Fractional~ can use the functions defined in ~Num~
  but not all ~Num~ can use ~Fractional~ functions
  + Since nothing in ~Num~'s definition requires an instance of ~Fractional~
+ Consider this function ~divideThenAdd x y = (x / y) + 1~
  + If you give it the type signature ~Num a => a -> a -> a~ you'll get a type error
    + Because it could not deduce ~(Fractional a)~ from the use of '/' from the context
      of ~(Num a)~
  + You could fix it with this ~Fractional a => a -> a -> a~ because the '/' operator
    is an instance of ~Fractional~ only
+ The function could have been written like ~f \:: (Num a, Fractional a) => a -> a -> a~
  which is also correct, but I assume it is redundant since ~Fractional~ is already an
  instance of, and inherits from ~Num~ which the compiler should be able to deduce and
  infer on its own

+ When you have a typeclass-constrained polymorphic value and need to evaluate it,
  the polymorphism must resolve to a specific concrete type
+ The concrete type must have an instance for all the required instances
  + i.e. if it is required to implement ~Num~ and ~Fractional~ then the concrete
    type can't be an ~Int~

#+BEGIN_SRC haskell
default Num Integer
default Real Integer
default Enum Integer
default Integral Integer
default Fractional Double
default RealFrac Double
default Floating Double
default RealFloat Double
#+END_SRC

+ The Haskell Report specifies these defaults relevant to numerical
  computations
+ These three operators are instances of ~Num~

#+BEGIN_SRC haskell
(+), (*), (-) :: Num a => a -> a -> a
#+END_SRC

* Exercises
** Page 272
    1.
#+BEGIN_SRC haskell
data TisAnInteger =
  TisAn Integer

instance Eq TisAnInteger where
  (==) (TisAn x) (TisAn y) = x == y
#+END_SRC

    2.
#+BEGIN_SRC haskell
data TwoIntegers =
  Two Integer Integer

instance Eq TwoIntegers where
  (==) (Two x y) (Two x' y') = x == x' && y == y'
#+END_SRC

    3.
#+BEGIN_SRC haskell
data StringOrInt = TisAnInt Int
                 | TisAString String

instance Eq StringOrInt where
 (==) (TisAnInt x) (TisAnInt y) = x == y
 (==) (TisAString a) (TisAString b) a == b
 (==) __ = False
#+END_SRC

    4.
#+BEGIN_SRC haskell
data Pair a =
  Pair a a

instance Eq a => Eq (Pair a) where
  (==) (Pair x x') (Pair y y') = x == y && y == y'
#+END_SRC

    5.
#+BEGIN_SRC haskell
data Tuple a b =
  Tuple a b

instance (Eq a, Eq b) => Eq (Tuple a b) where
  (==) (Tuple x y) (Tuple x' y') = x == x' && y == y'
#+END_SRC

    6.
#+BEGIN_SRC haskell
data Which a = ThisOne a
             | ThatOne a

instance (Eq a) => Eq (Which a) where
  (==) (ThisOne x) (ThisOne x') = x == x'
  (==) (ThatOne y) (ThatOne y') = y == y'
  (==) __ = False
#+END_SRC

    7.
#+BEGIN_SRC haskell
data EitherOr a b = Hello a
                  | Goodbye b

instance (Eq a, Eq b) => Eq (EitherOr a b) where
  (==) (Hello x) (Hello x') = x == y'
  (==) (Goodbye x) (Goodbye x') = x == y'
  (==) __ = False
#+END_SRC
** Page 275
   #+BEGIN_SRC haskell
quotRem, divMod :: Integral a => a -> a -> (a, a)
   #+END_SRC
   ~quotRem~ takes two numbers and returns a tuple containing the result
   of the integer divison, and remainder

   ~divMod~ is the same as ~quotRem~ but returns the modulo instead of remainder
